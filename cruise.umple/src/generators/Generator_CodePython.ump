/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

*/

namespace cruise.umple.compiler;
class PythonGenerator
{
  isA JavaGenerator;
  depend java.io.*;
  depend java.nio.file.*;  
  depend cruise.umple.compiler.java.*;
  depend cruise.umple.util.StringFormatter;
  depend cruise.umple.compiler.exceptions.*;
  
  private static final int TXL_VERSION = 6;
    
  @Override
  public ILang getLanguageFor(UmpleElement aElement)
  {
    if (aElement instanceof UmpleInterface)
    {
      return new JavaInterfaceGenerator();
    }
    else if (aElement instanceof UmpleClass)
    {
      return new PythonClassGenerator();
    } 
    else{
        return null;        
    }
  }
  
  @Override  
  public void writeFile(UmpleElement aClass) throws IOException
  {
    if (!isTxlInstalled()) {
      throw new UmpleCompilerException("TXL is required for Python code generation. Please go to https://www.txl.ca/txl-download.html to download and install TXL.", new IOException("TXL not found"));
    } 
    
    //System.out.println("toString() methods have been removed due to an issue with their generation.");
    String className=aClass.getName();
    UmpleClass uClass;
    if (aClass instanceof UmpleClass)
    { 
      uClass=(UmpleClass)aClass; 
      if(uClass.getHasProxyPattern()||(uClass.getIsDistributed()&&(getModel().getDistributePattern()==1||getModel().getDistributePattern()==2)))
      {
        aClass.setName(className+"Impl");
          }
      if(uClass.hasOuterClass())
      {
        return ; // inner classes should not be writen in single files.
      }
    }
    ILang language = getLanguageFor(aClass);
    String contents = language.getCode(getModel(), aClass);

    aClass.setName(className);
    String path = StringFormatter.addPathOrAbsolute( 
                  getModel().getUmpleFile().getPath(), 
                            getOutput()) + 
                            aClass.getPackageName().replace(".", File.separator);  
    if (aClass instanceof UmpleClass)
    { uClass=(UmpleClass)aClass;
      if(uClass.getNeedsDefaultInterface()||uClass.getIsDistributed()||uClass.getHasProxyPattern()){
        contents= super.WriteProxyFiles(contents,uClass,path);
      }    
      if(uClass.getHasProxyPattern()||(uClass.getIsDistributed()&&(getModel().getDistributePattern()==1||getModel().getDistributePattern()==2))){
        className=className+"Impl";
        //contents=contents.replaceAll("(,|, |\\(|\\( )(this)(,| ,|\\)| \\))","$1self$3");
      }        
    }
    
    File file = new File(path);
    file.mkdirs();   
    String filename = path + File.separator + className + ".java";
    BufferedWriter bw = new BufferedWriter(new FileWriter(filename));

    try
    {
      bw.write(contents);
      bw.flush();
    }
    finally
    {
      bw.close();
      contents = "";
    }
    
    generateTxlFiles();
    
    String pythonFilename = path + File.separator + className + ".py";
    String TXLScriptsPath = "./txl/umpleJavaToPython.txl";
    String[] TXLcommand = {"txl", filename, TXLScriptsPath, "-o", pythonFilename};
    
    try {
            
      Process p = Runtime.getRuntime().exec(TXLcommand);
      BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

      String line;
      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        line = null;
      }

      while (line!=null) {
        if(line.contains("error")) { 
           System.err.println("TXL ran into an error while processing one of the files. The file may be missing from the generated code.");
           return;
        }

        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
      }

      p.waitFor();

    } catch (IOException e) {
      System.err.println(e.getMessage());
	  throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    } catch (InterruptedException e) {
      System.err.println(e.getMessage());
      throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    } catch (Exception e) {
      throw new UmpleCompilerException("Unable to open Runtime Process.", e);    
    }

    try {
      File pythonFile = new File(pythonFilename);
      Scanner pyReader = new Scanner(pythonFile);
      while (pyReader.hasNextLine()) {
        contents += pyReader.nextLine() + "\n";
      }
      pyReader.close();
    } catch (FileNotFoundException e) {
      System.err.println("Error found with compilation of " + new File(pythonFilename).getName() + " : Output might be missing a file");
      return;
    }

    getModel().getGeneratedCode().put(aClass.getName(),contents);
    
    /* TODO
    if (aClass instanceof UmpleClass)
    {
      StringBuilder exceptionBuilder = new StringBuilder();
      for(String key:((JavaClassGenerator)language).uncaughtExceptions.keySet())
      {
        exceptionBuilder.append(((JavaClassGenerator)language).uncaughtExceptions.get(key).toString()+System.getProperty("line.separator"));
      }
      String exception = exceptionBuilder.toString();
      uncaughtExceptions.append(exception);
      if(((UmpleClass)aClass).getHasMainMethod())
      {
        mainClasses.add((UmpleClass)aClass);
      }
    } */
  }  
  
  private boolean isTxlInstalled()
  {
    //Check for TXL installation 
	try {
        
  	  Process p = Runtime.getRuntime().exec("txl");    
	  BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
	
	  String line;
	  if(reader.ready()) {
	    line = reader.readLine();
	  }
	  else {
	    line = null;
	  }
	
	  while (line!=null) {
	    if(!line.startsWith("TXL v")) {
	      throw new IOException("TXL not found.");
	    }
	
	    if(reader.ready()) {
	      line = reader.readLine();
	    }
	    else {
	      line = null;
	    }
	  }
	} catch (IOException e) {
	  System.err.println(e.getMessage());
	  System.err.println("TXL is required for Python code generation. Please go to https://www.txl.ca/txl-download.html to download and install TXL.");
	  return false;
	} catch (Exception e) {
	  throw new UmpleCompilerException("Unable to open Runtime Process.", e);
	}
	return true;
  }
    
  private void generateTxlFiles() throws IOException {
    	
    String versionPath = "txl/TXL-Version.txt";
    String versionContent = Integer.toString(TXL_VERSION) + "\nThese files were automatically generated by Umple for the python code generation and can be safely deleted after the generation.";
	String[][] filesData = {{ "txl/BooleanTranslation.txl", "%---------------------%\n% Boolean expressions %\n%---------------------%\n\nfunction replaceAllBoolean\n    replace [repeat statement]\n        statements [repeat statement]\n\n    by\n        statements\n            [replaceNullCheck]\n            [replaceNotNullCheck]\n            [replaceBoolNegation]\n            [replaceBoolAnd]\n            [replaceBoolOr]\n            [replaceTrue]\n            [replaceFalse]\n            [replaceClassMatchCheck]\nend function\n\nrule replaceNullCheck\n    replace [condition]\n        elem [value_no_recursion] '== 'null\n    by \n        elem 'is 'None\nend rule\n\nrule replaceNotNullCheck\n    replace [boolean_expression]\n        cond [condition]\n    deconstruct cond\n        elem [value_no_recursion] '!= 'null\n    by \n        'not '( elem 'is 'None ')\nend rule\n\nrule replaceBoolNegation\n    replace [value_no_recursion]\n        '! expr [boolean_expression]\n    by \n        'not expr\nend rule\n\nrule replaceBoolAnd\n    replace [boolean_operator]\n        '&&\n    by \n        'and\nend rule\n\nrule replaceBoolOr\n    replace [boolean_operator]\n        '|'|\n    by \n        'or\nend rule\n\nrule replaceTrue\n    replace [value]\n        'true\n    by \n        'True\nend rule\n\nrule replaceFalse\n    replace [value]\n        'false\n    by \n        'False\nend rule\n\nrule replaceClassMatchCheck\n    replace [boolean_expression]\n        'getClass().equals( id2 [id] '.getClass())\n    by  \n        'type(self) 'is 'type( id2 ')\nend rule\n"}, 
	{ "txl/ClassTranslation.txl", "%--------------------%\n%     Classes        %\n%--------------------%\n%decl and inheritance and external imports\nrule replaceConcreteClassesWithInheritance\n    replace $ [concrete_class_declaration]\n        _ [acess_modifier] 'class className [class_name] inheritances [repeat inheritance_list] '{ classBody [class_body_decl] '} \n    export className [class_name]\n        className\n    construct inheritanceClasses [list class_name]\n        _ [extractInheritanceBlockClasses each inheritances]\n    construct imports [repeat import_statement]\n        _ [createImports classBody inheritances]\n    by\n        imports 'class className '( inheritanceClasses ')':  classBody  [replaceClassBody]\nend rule\n\n%decl and external imports\nrule replaceConcreteClassesNoInheritance\n    replace $ [concrete_class_declaration]\n        _ [acess_modifier] 'class className [class_name] '{ classBody [class_body_decl] '} \n    export className [class_name]\n        className\n    construct emptyArgument [repeat inheritance_list]\n        _\n    construct imports [repeat import_statement]\n        _ [createImports classBody emptyArgument]\n    by\n    imports 'class className ':  classBody  [replaceClassBody]\nend rule\n\n%no imports\nrule replaceInterfacesNoInheritance\n    replace [interface_declaration]\n        _ [acess_modifier] 'interface className [class_name] '{ classBody [class_body_decl] '} \n    export className [class_name]\n        className\n    by\n        'from 'abc 'import 'ABC, 'abstractmethod 'class className '(ABC):  classBody [replaceClassBody] [replaceInterfaceBody]\nend rule\n\n%inheritance  imports\nrule replaceInterfacesWithInheritance\n    replace [interface_declaration]\n        _ [acess_modifier] 'interface className [class_name] inheritances [repeat inheritance_list] '{ classBody [class_body_decl] '} \n    export className [class_name]\n        className\n    construct inheritanceClasses [list class_name]\n        _ [extractInheritanceBlockClasses each inheritances]\n    construct imports [repeat import_statement]\n        _ [createImports classBody inheritances]\n    by\n        'from 'abc 'import 'ABC, 'abstractmethod imports 'class className '(ABC, inheritanceClasses '):  classBody [replaceClassBody] [replaceInterfaceBody]\nend rule\n\nfunction replaceInterfaceBody\n   replace [class_body_decl]\n        elements [repeat class_body_element]\n    construct declarations [repeat member_variable_declaration]\n        _ [^ elements]\n    export enumeratorDeclerations [repeat enum_declaration]\n        _ [^ elements]\n    construct memberVariables [repeat id]\n        _ [addMemberVariable each declarations]\n    construct listMemberVariables [repeat id]\n        _ [addListMemberVariable each declarations]\n    by\n        '@abstractmethod 'def '__init__(self): 'pass elements [replaceAllMethods]\nend function\n\n%WIP HERE \nfunction replaceClassBody\n    replace [class_body_decl]\n        elements [repeat class_body_element]\n    construct declarations [repeat member_variable_declaration]\n        _ [^ elements]\n    construct memberVariables [repeat id]\n        _ [addMemberVariable each declarations]\n    construct listMemberVariables [repeat id]\n        _ [addListMemberVariable each declarations]\n    export enumeratorDeclerations [repeat enum_declaration]\n        _ [^ elements]\n    by\n        elements [removeMemberVariableDeclarations] [replaceEnumDeclaration] \n            [replaceAllLists listMemberVariables]\n            [replaceConstructor] \n            [replaceConstructorNoArgs]\n            [replaceAllMethods]\n            [replaceAllMemberVariableNames memberVariables] \nend function\n\nfunction removeMemberVariableDeclarations\n    replace [repeat class_body_element]\n        elems [repeat class_body_element]\n    construct empty [repeat class_body_element]\n        _\n    by\n        empty [addIfNotMemberDecleration each elems]\nend function\nfunction addIfNotMemberDecleration elem [class_body_element]\n    replace [repeat class_body_element]\n        keepers [repeat class_body_element]\n    construct declerations [repeat member_variable_declaration]\n        _ [^ elem]\n    construct declerationSize [number]\n        _ [length declerations]\n    where\n        declerationSize [= 0]\n    by\n        keepers [. elem]\nend function"}, 
	{ "txl/ConstructorTranslation.txl", "rule replaceConstructor\n    replace [constructor]\n         mod [acess_modifier] className [id]'( params [list method_parameter +] ') '{ statements [repeat statement]  '}\n    construct newParams [list id]\n    by\n        'def '__init__(self, newParams [translateParams each params]'):  statements [replaceStatements]\nend rule\n\nrule replaceConstructorNoArgs\n    replace [constructor]\n         mod [acess_modifier] className [id]'() '{ statements [repeat statement]  '}\n    by\n        'def '__init__(self):  statements [replaceStatements]\nend rule"}, 
	{ "txl/EnumTranslation.txl", "rule replaceEnumDeclaration\n    replace [enum_declaration]\n        _ [opt acess_modifier] 'enum enumName [id] '{ vals [list id] '}\n    construct enumValDeclarations [repeat enum_value_declaration]\n        _ [generateEnumValues vals]\n    by\n        'class enumName '(Enum'):\n            'def '_generate_next_value_('name, 'start, 'count, 'last_values)':\n                'return 'name\n            'def '__str__'(self):\n                'return 'str(self. 'value)\n        enumValDeclarations\nend rule\n\nfunction generateEnumValues vals [list id]\n    replace [repeat enum_value_declaration]\n        decls [repeat enum_value_declaration]\n    by\n        decls [generateEnumValue each vals]\nend function\n\nfunction generateEnumValue val [id]\n    replace [repeat enum_value_declaration]\n        decls [repeat enum_value_declaration]\n    construct decl [enum_value_declaration]\n        val '= 'auto()\n    by decls [. decl]\nend function"}, 
	{ "txl/ImportProcessing.txl", "function createImports classBody [class_body_decl] inheritances [repeat inheritance_list]\n    replace [repeat import_statement]\n        empty [repeat import_statement]\n    construct declarations [repeat member_variable_declaration]\n        _ [^ classBody]\n    construct declarationClassesToImport [repeat id]\n        _ [getClassesToImport classBody each declarations]\n    construct allInternalClassesToImport [repeat id]\n        _ [extractInheritanceImportClasses classBody each inheritances] [concatenateRepeatNoDuplicates declarationClassesToImport]\n    construct allImports [repeat import_statement]\n        _ [addImportStatement each allInternalClassesToImport] [addExternalImports classBody]\n    by\n        allImports\nend function \n\nfunction addImportStatement a [id]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    construct newImport [import_statement]\n        'from a 'import a\n    by\n        imports [. newImport]\nend function\n\nfunction getClassesToImport classBody [class_body_decl] declaration [member_variable_declaration]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct declaration\n        _[opt acess_modifier] _[opt static] _[opt volatile] varDec [variable_declaration]\n    deconstruct varDec\n        class [class_name] _ [id]';\n    construct classesToImport [repeat id]\n        _ [extractListClass classBody class] [extractRegularClass classBody class]\n    by \n        empty [addToRepeatIfNotThere each classesToImport] \nend function \n\nfunction isTypeEnum typeName [id]\n    match * [enum_declaration]\n        _ [opt acess_modifier] 'enum enumName [id] '{ _ [list id]'}\n    where\n        enumName [= typeName]\nend function\n\nfunction extractInheritanceBlockClasses inheritanceList [inheritance_list]\n    replace [list class_name]\n        classes [list class_name]\n    deconstruct inheritanceList\n        _[inheritance_statement] classesToAdd [list class_name]\n    by\n        classes [, classesToAdd] \nend function\n\nfunction extractInheritanceImportClasses classBody [class_body_decl] inheritanceList [inheritance_list]\n    replace [repeat id]\n        classesToImport [repeat id]\n    deconstruct inheritanceList\n        _[inheritance_statement] classesToAdd [list class_name]\n    construct classIds [repeat id]\n        _ [extractListClass classBody each classesToAdd] [extractRegularClass classBody each classesToAdd]\n    by\n        classesToImport [. classIds] \nend function\n\n\nfunction concatenateRepeatNoDuplicates elems [repeat id]\n    replace [repeat id]\n        currentList [repeat id]\n    by\n        currentList [addToRepeatIfNotThere each elems] \nend function\n\nfunction addToRepeatIfNotThere elem [id]\n    replace [repeat id]\n        currentList [repeat id]\n    where not \n        currentList [contains elem]\n    by\n        currentList [. elem]\nend function\n\nfunction extractListClass classBody [class_body_decl] class [class_name]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct class\n        _ [id]'< ids [list id] '>\n    construct unfiltered [repeat id]\n        _ [listToRepeat ids] \n    construct filtered [repeat id]\n        _ [filterOutUnwantedTypes classBody unfiltered]\n    by\n        filtered\nend function\n\nfunction filterOutUnwantedTypes classBody [class_body_decl] ids [repeat id]\n    replace [repeat id]\n        empty [repeat id]\n    by \n        empty [addIfNotDefaultTypeOrEnum classBody each ids]\nend function\n\nfunction addIfNotDefaultTypeOrEnum classBody [class_body_decl] id [id]\n    replace [repeat id]\n        current [repeat id]\n    where not \n        id [matchDefaultType]\n    where not \n        classBody [isTypeEnum id]\n    by\n        current [. id] \nend function\n\nrule matchDefaultType\n    match [id]\n        id [id]\n    construct defaults [repeat id]\n        'byte 'short 'int 'long 'float 'double 'boolean 'char 'String 'Array\n    where\n        defaults [contains id]    \nend rule\n\nfunction extractRegularClass classBody [class_body_decl] class [class_name]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct class\n        id [id]\n    where not \n        id [matchDefaultType]\n    where not \n        classBody [isTypeEnum id]\n    by\n        empty [. id]\nend function\n\nfunction listToRepeat ids [list id]\n    replace [repeat id]\n        aRep [repeat id]\n    by \n        aRep [addToRepeat each ids]\nend function\n\nfunction addToRepeat a [id]\n     replace [repeat id]\n        aRep [repeat id]\n    by \n        aRep [. a]\nend function\n\nfunction repeatToList aRep [repeat id]\n    replace [list id]\n        aList [list id]\n    by \n        aList [addToList each aRep]\n\nend function\n\n\nfunction addToList anys [id]\n     replace [list id]\n        aRep [list id]\n    by \n        aRep [, anys]\nend function\n\n\nfunction translateParams PreviousParam [method_parameter]\n    replace [list id]\n        SequenceSoFar [list id]\n    deconstruct PreviousParam\n        _ [id] paramName [id]\n    by\n        SequenceSoFar [, paramName]\nend function\n\nfunction addListMemberVariable MemberVariable [member_variable_declaration]\n    replace [repeat id]\n        SequenceSoFar [repeat id]\n    deconstruct MemberVariable\n        _[opt acess_modifier] decl [variable_declaration]\n    deconstruct decl\n        'List '< _ [list id] '> memberName [id]';\n    by\n        SequenceSoFar [. memberName]\nend function\n\nfunction addMemberVariable MemberVariable [member_variable_declaration]\n    replace [repeat id]\n        SequenceSoFar [repeat id]\n    deconstruct MemberVariable\n        _[opt acess_modifier] decl [variable_declaration]\n    deconstruct decl\n        _ [class_name] memberName [id]';\n    by\n        SequenceSoFar [. memberName]\nend function\n\nfunction replaceAllMemberVariableNames memberVariables [repeat id]\n    replace [any]\n        any [any]\n    by \n        any \n            [replaceMemberVariableNames memberVariables] \n            [replaceMemberVariableNamesWithThis memberVariables]\n            [replaceMemberVariableNamesBrackets memberVariables]\nend function\n\nrule replaceMemberVariableNames memberVariables [repeat id]\n    replace [nested_identifier]\n         name [id] rep [repeat attribute_access]\n    where \n        memberVariables [contains name]\n    construct underscore [id]\n        '_\n    construct newName [id]\n        underscore [+ name] \n    by\n        'self '. newName rep\nend rule\n\nrule replaceMemberVariableNamesWithThis memberVariables [repeat id]\n    replace [nested_identifier]\n        'this '. name [id] rep [repeat attribute_access]\n    where \n        memberVariables [contains name]\n    construct underscore [id]\n        '_\n    by\n        'self '. underscore [+ name] rep\nend rule\n\nrule replaceMemberVariableNamesBrackets memberVariables [repeat id]\n    replace [nested_identifier]\n         name [id] '[ val [value] ']  rep [repeat attribute_access]\n    where \n        memberVariables [contains name]\n    construct underscore [id]\n        '_\n    construct newName [id]\n        underscore [+ name]\n    by\n        'self '. newName '[ val ']  rep\nend rule\n\n\nrule contains Object [id]\n    match [id]\n        Object\nend rule\n\n%--------------------%\n%  External imports  %\n%--------------------%\n\nfunction addExternalImports body [class_body_decl]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    by\n        imports [addOSImportIfNeeded body]\n        [addEnumImportIfNeeded body]\nend function\n\n\nfunction addOSImportIfNeeded body [class_body_decl]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    where\n        body [shouldOsImport]\n    construct newImport [import_statement]\n        'import 'os\n    by \n        imports [. newImport]\nend function\n\nfunction shouldOsImport\n    match * [nested_identifier]\n        'System.getProperties().getProperty(\"line.separator\")\nend function\n\nfunction addEnumImportIfNeeded body [class_body_decl]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    where\n        body [shouldEnumImport]\n    construct newImport [import_statement]\n        'from 'enum 'import 'Enum, 'auto\n    by \n        imports [. newImport]\nend function\n\nfunction shouldEnumImport\n    match * [enum_declaration]\n        _ [enum_declaration]\nend function"}, 
	{ "txl/Java.Grm", "comments\n    //\n    /*  */\nend comments\n\ncompounds \n    'self. '== '!=\nend compounds \n\ntokens\n    number  \"(-\\s?)?\\d+(.\\d+)?\"\nend tokens\n\n%--------------------%\n%     Statements     %\n%--------------------%\n\nkeys\n return new if else for true false while this super self tuple len True False + - * / ? ; : pass\nend keys\n\ndefine acess_modifier\n        'private\n    |   'public\n    |   'protected\nend define\n\ndefine boolean_operator\n        '&&\n    |   '|'|\nend define\n\ndefine comparator\n        '==\n    |   '!=\n    |   '>\n    |   '<\n    |   '>=\n    |   '<=\nend define\n\ndefine arithmatic_operator\n        '+\n    |   '-\n    |   '*\n    |   '/\n    |   '%\nend define\n\ndefine program\n    [repeat package_statement]  \n    [repeat import_statement]\n    [repeat class_declaration]\nend define\n\ndefine package_statement \n    'package [imported]';\nend define\n\ndefine import_statement \n    'import [imported]';\nend define\n\n\n\ndefine imported\n        [id]\n    |   '*\n    |   [id]'. [imported]\nend define\n\ndefine class_name\n    [id]'< [list id] '>\n    | [id]   \nend define\n\ndefine arithmatic_expression\n       [value_no_recursion] [arithmatic_operator] [arithmatic_expression]\n    |   [value_no_recursion]\nend define\n\ndefine nested_identifier\n     [nestable_value] [SPOFF] [repeat attribute_access] [SPON]\nend define\n\ndefine attribute_access\n       '. [nestable_value] \nend define\n\ndefine nestable_value \n        [function_call]\n    |    [id]\n    |   'this\n    |   'super\n    |   [class_name]\nend define\n\ndefine value_no_recursion \n        [new_call]\n    |   '( [value]')\n    |   [nested_identifier]\n    |   [number]\n    |   [stringlit]\n    |   'null\n    |   'true\n    |   'false\n    |   [casting]\n    |   '! [boolean_expression]\nend define\n\ndefine value\n       [value_no_ternary]\n    |   [ternary]\nend define\n\ndefine value_no_ternary\n        [value_no_recursion]\n    |   [boolean_expression]\n    |   [arithmatic_expression]\nend define\n\ndefine new_call\n    'new [class_name] '( [list value] ')\nend define\n\ndefine variable_declaration\n        [class_name] [assignment] '; [NL]\n    |   [class_name] [nested_identifier]';\nend define\n\ndefine assignment\n        [nested_identifier] '= [value] \n    |    [nested_identifier]'++\n    |    [nested_identifier]'--\n    |   [nested_identifier] '+= [value]\n    |   [nested_identifier] '-= [value]\nend define\n\n\ndefine stmt_return\n        'return [value] '; [NL]\nend define\n\ndefine statement\n        [variable_declaration]\n    |   [stmt_return]\n    |   [conditional_block]\n    |   [for_loop]\n    |   [for_in_loop]\n    |   [while_loop]\n    |   [nested_identifier]'; [NL]\n    |   [assignment] '; [NL]\n    |   [throw_statement]\n    |   [switch_case]\nend define\n\ndefine while_loop\n    'while( [value] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine ternary\n    [value_no_recursion] '? [value] ': [value]\nend define\n\ndefine for_loop\n    'for( [variable_declaration] [value]'; [assignment]') '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine for_in_loop\n    'for( [class_name] [id] ': [nested_identifier]')'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine switch_case\n    'switch( [value] ') '{ [repeat switch_case_case] [opt switch_case_default] '}\nend define\n\ndefine switch_case_case\n    'case [value] ': [repeat statement] 'break;\nend define\n\ndefine switch_case_default\n    'default ': [repeat statement]\nend define\n\ndefine conditional_block\n    [if] [repeat else_if] [opt else]\nend define\n\ndefine if \n    'if '( [value] ') '{  [repeat statement]  '}\nend define\n\ndefine else_if\n    'else 'if '( [value] ') [NL]'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine else\n    'else [NL]'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine throw_statement\n    'throw 'new [id] '( [stringlit] ');\nend define\n\ndefine casting\n    '( [class_name]') [nested_identifier]\nend define\n\ndefine function_call\n        [id][SPOFF] '( [SPON] [list value]')    \nend define\n\ndefine boolean_expression\n        [condition] [repeat boolean_continuation]\nend define\n\ndefine boolean_continuation\n        [boolean_operator] [condition]\nend define\n\ndefine condition\n        [value_no_recursion] [comparator] [value]\n    |   [value_no_recursion]\nend define\n\ndefine method_parameter\n    [class_name] [id]\nend define\n\ndefine decorator\n    '@ [SPOFF] [id] [SPON] [NL]\nend define\n\ndefine concrete_method_declaration\n        [opt decorator] [acess_modifier] [opt static] [class_name] [id] '( [list method_parameter] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine method_declaration\n        [concrete_method_declaration]\n    |   [abstract_method_declaration]\nend define\n\ndefine abstract_method_declaration\n    [acess_modifier] [class_name] [id] '( [list method_parameter] '); [NL]\nend define\n\ndefine inheritance_statement\n        'extends\n    |   'implements\nend define\n\n\n%--------------------%\n%        Class       %\n%--------------------%\n\ndefine class_declaration\n        [concrete_class_declaration]\n    |   [interface_declaration]\nend define\n\ndefine concrete_class_declaration\n    [acess_modifier] 'class [class_name] [repeat inheritance_list] [NL] '{ [NL] [IN] [class_body_decl] [EX] '} [NL]\nend define\n\ndefine inheritance_list\n    [inheritance_statement] [list class_name]\nend define\n\ndefine interface_declaration\n        [acess_modifier] 'interface [class_name] [repeat inheritance_list] [NL] '{ [NL] [IN] [class_body_decl] [EX] '} [NL]\nend define\n\ndefine class_type\n        'class\n    |   'interface\nend define\n\ndefine static\n    'static\nend define\n\ndefine volatile\n    'volatile\nend define\n\ndefine constructor\n    [acess_modifier] [id]'( [list method_parameter] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine enum_declaration\n    [opt acess_modifier] 'enum [id] '{ [list id]'}\nend define\n\ndefine member_variable_declaration\n    [opt acess_modifier] [opt static] [opt volatile] [variable_declaration]\nend define\n\ndefine class_body_decl\n    [repeat class_body_element]\nend define\n\ndefine class_body_element\n        [enum_declaration]\n    |   [member_variable_declaration]\n    |   [constructor]\n    |   [method_declaration]\nend define\n"}, 
	{ "txl/ListTranslation.txl", "%--------------------%\n%  List replacement  %\n%--------------------%\n\nfunction replaceAllLists memberLists [repeat id]\n    replace [any]\n        any [any]\n    by \n        any\n            [replaceListAssignement memberLists]\n            [replaceListUnmutable memberLists]\n            [replaceGetListContent memberLists]\n            [replaceListGetSize memberLists]\n            [replaceListGetIndex memberLists]\n            [replaceListContains memberLists]\n            [replaceListAddAtIndex memberLists]\n            [replaceListAddNoIndex memberLists]\n            [replaceListCopy]\nend function \n\nrule replaceListAssignement memberLists [repeat id]\n    replace [assignment]\n        id [id] '= 'new 'ArrayList '< _[list id] '> '(') \n    where\n        memberLists [contains id]\n    by \n        id '= '[']\nend rule\n\nrule replaceListCopy\n    replace [assignment]\n        id [id] '= 'new 'ArrayList '< _[list id] '> '( oldList [nested_identifier]') \n    deconstruct oldList\n        val [nestable_value] rep [repeat attribute_access]\n    construct newNested [repeat attribute_access]\n        '.copy()\n    by \n        id '= val rep [. newNested]\nend rule\n\nrule replaceListUnmutable memberLists [repeat id]\n    replace [value]\n        'Collections.unmodifiableList( id [id] ')\n    where\n        memberLists [contains id]\n    by \n        'tuple( id ')\nend rule\n\n\nrule replaceGetListContent memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '. 'get( index [value] ')  rest [repeat attribute_access]\n    where\n        memberLists [contains id]\n    by \n        id '[ index '] rest \nend rule\n\nrule replaceListGetSize memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.size()\n    where\n        memberLists [contains id]\n    by \n        'len( id ')\nend rule\n\nrule replaceListGetIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.indexOf( val [value] ')\n    where\n        memberLists [contains id]\n    by \n        id '.index( val ')\nend rule\n\nrule replaceListContains memberLists [repeat id]\n    replace [value]\n        nested [nested_identifier]\n    deconstruct nested\n        id [id]'. 'contains '( val [value_no_recursion] ')\n    where\n        memberLists [contains id]\n    by \n        val 'in id\nend rule\n\nrule replaceListAddAtIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.add( position [value] ', value [value] ')\n    where\n        memberLists [contains id]\n    by \n        id '.insert( position ', value ')\nend rule\n\nrule replaceListAddNoIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.add( value [value] ')\n    where\n        memberLists [contains id]\n    by \n        id '.append( value ')\nend rule"}, 
	{ "txl/MethodTranslation.txl", "%--------------------%\n%     Methods        %\n%--------------------%\n\nfunction replaceAllMethods\n    replace [repeat class_body_element]\n        elems [repeat class_body_element]\n    by\n        elems\n            [removeOverrideDecorator]\n            [replaceToString]\n            [replaceAbstractMethod]\n            [replaceAbstractMethodNoArgs]\n            [replaceConcreteMethod]\n            [replaceConcreteMethodNoArgs]\n            [replaceStaticMethod]\nend function\n\nrule removeOverrideDecorator\n    replace [opt decorator]\n        '@Override\n    by \n        _\nend rule\n\nrule replaceConcreteMethod\n    replace [concrete_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id]'( params [list method_parameter +] ') '{ statements [repeat statement] '}\n    construct newParams [list id]\n    by\n        'def methodName '(self, newParams [translateParams each params] '):  statements [replaceStatements]\nend rule\n\nrule replaceConcreteMethodNoArgs\n    replace [concrete_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id]'() '{ statements [repeat statement] '}\n    by\n        'def methodName '(self):  statements [replaceStatements]\nend rule\n\nrule replaceAbstractMethod\n    replace [abstract_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id] '( params [list method_parameter +] ');\n    construct newParams [list id]\n    by\n        '@abstractmethod 'def methodName '(self, newParams [translateParams each params] '): 'pass\nend rule\n\nrule replaceAbstractMethodNoArgs\n    replace [abstract_method_declaration]\n        _[acess_modifier] _[class_name] methodName [id]'();\n    by\n        '@abstractmethod 'def methodName '(self): 'pass\nend rule\n\nrule replaceToString\n    replace [method_declaration]\n        _[acess_modifier] _[class_name]  'toString '() '{ statements [repeat statement] '}\n    by\n        'def '__str__ '(self):  statements [replaceStatements]\nend rule\n\nrule replaceStaticMethod\n    replace [method_declaration]\n        _[acess_modifier] _[static] _[class_name] methodName [id]'() '{ statements [repeat statement] '}\n    by\n        '@staticmethod 'def methodName '():  statements [replaceStatements]\nend rule\n"}, 
	{ "txl/Python.Grm", "include \"Java.Grm\"\n\n%Num of char in a line before TXL splits it in two. Hopefully a temporary solution.\n#pragma -width 1073741824\n\n\nredefine boolean_operator\n    ...\n    |'and\n    | 'or\nend redefine\n\nredefine comparator\n    ...\n    |   'is\n    |   'in\nend redefine\n\nredefine nestable_value\n    ...\n    | 'self\n    |  [array_access]\nend redefine\n\n\ndefine array_access\n    [id] [SPOFF] '[ [value] '] [SPON]\nend define\n\nredefine assignment\n    ...\n    |   [nested_identifier] '= [value] [NL]\nend redefine\n\nredefine statement\n    ...\n    |  [nested_identifier] [NL]\n    | 'pass [NL]\nend redefine\n\nredefine stmt_return\n    ...\n    |   'return [value] [NL]\nend redefine\n\n\nredefine value_no_recursion\n    ...\n    |   'True\n    |   'False\n    |   'None\n    |   '[ [list value] ']\n    |   'not [boolean_expression] \nend redefine\n\ndefine python_function_name\n        'tuple\n    |   'len\n    |   'super\nend define\n\nredefine function_call\n    ...\n    |   [python_function_name] [SPOFF] '( [SPON] [list value]')\nend redefine\n\n\nredefine for_loop\n    ...\n    |'for [nestable_value] 'in 'range( [value] ', [value] ', [value] '): [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine for_in_loop\n    ...\n    | 'for [id] 'in  [nested_identifier] [SPOFF] ': [SPON] [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine while_loop\n    ...\n    | [opt variable_declaration] 'while [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine if \n    ... \n    |   'if [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine else_if\n    ...\n    |   'elif [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine else\n    ...\n    |   'else:  [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine throw_statement\n    ...\n    |   'raise 'RuntimeError( [stringlit] ') [NL]\nend redefine\n\n\nredefine method_parameter\n    ...\n    | [id]\nend redefine\n\nredefine ternary\n    ...\n    |   [value_no_ternary] 'if [value] 'else [value]\nend redefine\n\nredefine concrete_method_declaration\n    ...\n    |   [opt decorator] 'def  [id] [SPOFF]'(self, [SPON] [list id] [SPOFF] '): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [opt decorator] 'def  [id] [SPOFF]'(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [opt decorator] 'def  [id] [SPOFF]'(): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\nredefine abstract_method_declaration\n    ...\n    |   [SPOFF] '@abstractmethod [SPON] [NL] 'def  [id] [SPOFF]'(self, [SPON] [list id] [SPOFF] '): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [SPOFF] '@abstractmethod [SPON] [NL] 'def  [id] [SPOFF]'(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\n\nredefine constructor\n    ...\n    | 'def '__init__ [SPOFF] '(self, [SPON] [list id] [SPOFF]'): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    | 'def '__init__ [SPOFF] '(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\nredefine concrete_class_declaration\n    ... \n    | [repeat import_statement] [NL] 'class [class_name] [SPOFF] [opt inheritance_group] ': [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\nend redefine\n\ndefine inheritance_group\n    '( [SPON] [list class_name] [SPOFF] ')\nend define\n\nredefine interface_declaration\n    ... \n    |  [import_statement] [NL] 'class [class_name] [SPOFF] '(ABC): [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\n    |  [import_statement] [repeat import_statement] [NL] 'class [class_name] [SPOFF] '(ABC, [SPON] [list class_name] [SPOFF] '): [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\nend redefine\n\nredefine class_body_decl\n    ...\n    | 'pass\n    | [opt constructor] [repeat method_declaration]\nend redefine\n\nredefine variable_declaration\n    ...\n    |   [assignment] [FL]\n    |   [id] [FL]\nend redefine\n\nredefine import_statement\n    ...\n    |   'from [class_name] 'import [class_name] [NL]\n    |   'from [class_name] 'import [list class_name] [NL]\n    |   'import [id] [NL]\nend redefine \n\nredefine enum_declaration\n    ...\n    | 'class [id] [SPOFF] '(Enum'): [SPON][NL] \n        [IN] 'def '_generate_next_value_ [SPOFF] '( [SPON] 'name, 'start, 'count, 'last_values) [SPOFF] ': [SPON] [NL] \n            [IN] 'return 'name [NL] \n        [EX] 'def '__str__ [SPOFF] '(self): [SPON] [NL] \n            [IN] 'return 'str [SPOFF] '(self. 'value) [SPON] [NL] \n        [EX] [repeat enum_value_declaration] [NL]\n    [EX]\nend redefine\n\ndefine enum_value_declaration\n    [id] '= 'auto [SPOFF] () [SPON] [NL]\nend define\n\nredefine switch_case\n    ...\n    |   'match [value] ': [NL] [IN] [repeat switch_case_case] [opt switch_case_default] [EX]\nend redefine\n\nredefine switch_case_case\n    ...\n    |   'case [value] ': [NL] [IN] [repeat statement] [EX]\nend redefine\n\nredefine switch_case_default\n    ...\n    |   'case 'default ': [NL] [IN] [repeat statement] [EX]\nend redefine\n"}, 
	{ "txl/StatementTranslation.txl", "%--------------------%\n%     Statements     %\n%--------------------%\nfunction replaceStatements\n    replace [repeat statement]\n        statements [repeat statement]\n    by \n        statements\n            [reorderNestedIdentifier]\n            [replaceSwitchCase]\n            [addClassPrefixToEnum]\n            [replaceForLoop]\n            [replaceForInLoop]\n            [replaceAssignmentStatement] \n            [replaceReturn] \n            [replaceNoStatements] \n            [addSelfToOwnMethodCalls]\n            [replaceThisFunctionCall]\n            [replaceNestedStatement]\n            [replaceDecleration]\n            [replaceTernary]\n            [replaceAllBoolean]\n            [replaceDeclerationWithAssignment]\n            [replaceIf]\n            [replaceElseIf]\n            [replaceElse]\n            [replaceWhile]\n            [replaceNull]\n            [replaceThis]\n            [replaceIncrement]\n            [replaceDecrement]\n            [replaceThrowError]\n            [replaceNewCall]\n            [replaceCasting]\n            [correctSuperInit]\n            [correctSuperFunctions]\n            [replaceSuperToString]\n            [replaceNewLine]\n            [replaceHexIdentity]\nend function\n\nfunction replaceNoStatements\n    replace [repeat statement]\n    by \n        'pass  \nend function\n\nrule replaceAssignmentStatement\n    replace [statement]\n        identifier [nested_identifier] '= val [value] '; \n    by \n        identifier '= val\nend rule\n\nrule replaceReturn\n    replace [stmt_return]\n        'return val [value] ';\n    by \n        'return val\nend rule\n\nrule addSelfToOwnMethodCalls\n    replace [nested_identifier]\n        funcName [id] '( values [list value]') rep [repeat attribute_access]\n    where\n        funcName [~= 'str]\n    by\n        'self '. funcName '( values') rep\nend rule\n\nrule replaceThisFunctionCall\n    replace [nested_identifier]\n        'this. funcName [id] '( values [list value]')\n    by\n        'self '. funcName '( values')\nend rule\n\nrule replaceNestedStatement\n    replace [statement]\n        stmt [statement]\n    deconstruct stmt\n        value [nested_identifier] ';\n    by\n        value\nend rule\n\n\nrule replaceThis\n    replace [value]\n        'this\n    by \n        'self\nend rule\n\nrule replaceDeclerationWithAssignment\n    replace [variable_declaration]\n        _ [class_name] assignment [assignment] ';\n    by \n        assignment\nend rule\n\nrule replaceDecleration\n    replace [variable_declaration]\n        _[class_name] varName [id]';\n    by \n        varName \nend rule\n\nrule replaceIf\n    replace [if]\n        'if '( bool [value] ') '{ statements [repeat statement]  '}\n    by \n        'if bool ': statements\nend rule\n\nrule replaceElseIf\n    replace [else_if]\n        'else 'if '( bool [value] ') '{  statements [repeat statement]  '} \n    by \n        'elif bool ': statements\nend rule\n\n\nrule replaceElse\n    replace [else]\n        'else '{  statements [repeat statement]  '} \n    by \n        'else ': statements\nend rule\n\n\nrule replaceTernary\n    replace [ternary]\n        condition [value_no_recursion] '? opt1 [value] ': opt2 [value]\n    by\n        '( opt1 ') 'if condition 'else opt2\nend rule\n\nrule replaceWhile\n    replace [while_loop]\n        'while( val [value] ')  '{ statements [repeat statement] '} \n    by\n        'while val ':  statements \nend rule\n\nrule replaceNull\n    replace [value]\n        'null\n    by\n        'None\nend rule\n\n\nrule replaceDecrement\n    replace [assignment]\n        nest [nestable_value] '--\n    construct test [arithmatic_expression]\n        nest '- '1\n    by \n        nest '= test\nend rule\n\nrule replaceIncrement\n    replace [assignment]\n        nest [nestable_value] '++\n    by \n        nest '= nest '+ '1\nend rule\n\nrule replaceForLoop\n    replace [statement]\n        'for( decl [variable_declaration] goal [value]'; assignment [assignment]') '{  stmts[repeat statement]  '} \n    deconstruct decl\n        _[class_name] name [id] '= start [value] ';\n    construct declaration [variable_declaration]\n        name '= start\n    construct newStatements [repeat statement]\n        assignment\n    by \n        declaration 'while goal ':  stmts  [. newStatements]\nend rule\n\nrule replaceForInLoop\n    replace [for_in_loop]\n        'for( _[class_name] var [id] ': nested [nested_identifier]')'{ stmts [repeat statement] '} \n    by \n        'for var 'in  nested':  stmts\nend rule\n\nrule replaceThrowError\n    replace [throw_statement]\n        'throw 'new _[id] '( message [stringlit] ');\n    by\n        'raise 'RuntimeError(  message ') \nend rule \n\nrule replaceCasting\n    replace [value]\n        '( _ [class_name]') name [nested_identifier]\n    by \n        name \nend rule\n\nrule replaceNewCall\n    replace [value]\n        'new class [class_name] '( vals [list value] ')\n    deconstruct class\n        id [id]\n    by\n        id '( vals ')\nend rule\n\nrule correctSuperInit\n    replace [nested_identifier]\n        'super( params [list value] ')\n    by\n        'super().__init__( params ')\nend rule\n\nrule correctSuperFunctions\n    replace [nested_identifier]\n        'super rep [repeat attribute_access]\n    by\n        'super() rep\nend rule\n\nrule replaceSuperToString\n    replace [nested_identifier]\n        'super().toString() rep [repeat attribute_access]\n    by\n        'super().__str__() rep\nend rule\n\nrule replaceNewLine\n    replace [nested_identifier]\n        'System.getProperties().getProperty(\"line.separator\")\n    by\n        'os.linesep\nend rule \n\nrule replaceHexIdentity\n    replace [nested_identifier]\n        'Integer.toHexString(System.identityHashCode( val [value_no_recursion] '))\n    by\n        'format( 'id( val '), '\"x\")\nend rule\n\nrule replaceSwitchCase\n    replace [switch_case]\n        'switch( val [value] ') '{ cases [repeat switch_case_case]  default [opt switch_case_default] '}\n    by\n        'match val ': cases [replaceSwitchCaseCase]  default [replaceSwitchCaseDefault]\nend rule\n\nrule replaceSwitchCaseCase\n    replace [switch_case_case]\n        'case val [value] ': stmts [repeat statement] 'break;\n    by\n        'case val [fixEnumValueWithNoEnum] ': stmts [replaceNoStatements]\nend rule\n\nrule replaceSwitchCaseDefault\n    replace [switch_case_default]\n        'default ': stmts [repeat statement]\n    by\n        'case 'default ': stmts [replaceNoStatements]\nend rule\n\nrule fixEnumValueWithNoEnum\n    replace $ [value]\n        val [value]\n    deconstruct val\n        _ [id]\n    import enumeratorDeclerations [repeat enum_declaration]\n    by\n        val [fixEnumValueWithNoEnumCheck each enumeratorDeclerations]\nend rule\n\nrule fixEnumValueWithNoEnumCheck enum [enum_declaration]\n    replace [value]\n        identifier [id]\n    deconstruct enum \n        _ [opt acess_modifier] 'enum enumName [id] '{ vals [list id]'}\n    where\n        identifier [= each vals]\n    by\n        enumName '. identifier\nend rule\n\nrule addClassPrefixToEnum\n    replace [nested_identifier]\n        enumName [id] '.  enumVal [id]\n    where\n        enumName [isAnEnum]\n    import className [class_name]\n    construct test [id]\n        enumName\n    by\n        className '. enumName '. enumVal [debug]\nend rule\n\nfunction isAnEnum\n    match [id]\n        name [id]\n    import enumeratorDeclerations [repeat enum_declaration]\n    where\n        name [isSpecificEnum each enumeratorDeclerations]\nend function\n\nfunction isSpecificEnum enum [enum_declaration]\n    match [id]\n        name [id]\n    deconstruct enum    \n        _ [opt acess_modifier] 'enum enumName [id] '{ _ [list id]'}\n    where\n        name [= enumName]\nend function\n%--------------------------------%\n%  Nested Identifier reordering  %\n%--------------------------------%\n\nrule reorderNestedIdentifier\n    replace [nested_identifier]\n        nested [nested_identifier]\n    construct seeking [attribute_access]\n        '.toString()\n    where \n        nested [containsAttributeAccess seeking]\n    by\n        nested [reorderToString]\nend rule\n\nfunction reorderToString\n    replace [nested_identifier]\n        nested [nested_identifier]\n    construct funcName [id]\n        'str\n    construct seeking [attribute_access]\n        '.toString()\n    by\n        nested [reorderSpecific seeking funcName]\nend function\n\nfunction reorderSpecific seeking [attribute_access] funcName [id]\n    replace [nested_identifier]\n        nested [nested_identifier]\n    deconstruct nested\n        root [nestable_value] rep [repeat attribute_access]\n    where \n        nested [containsAttributeAccess seeking]\n    construct zero [number]\n        '0 \n    construct count [number]\n        zero [findCount seeking rep]\n    by\n        nested [swap count funcName]\nend function\n\nfunction findCount seeking [attribute_access] rep [repeat attribute_access]\n    replace [number]\n        count [number]\n    construct repLength [number]\n        _ [length rep]\n    construct head [repeat attribute_access]\n        rep [head 1]\n    where \n        repLength [> 0]\n    construct remaining [repeat attribute_access]\n        rep [tail 2]\n    where not\n        head [containsAttributeAccess seeking] \n    by\n        count [+ 1] [findCount seeking remaining]\nend function\n\nfunction swap count [number] funcName [id]\n    replace [nested_identifier]\n        root [nestable_value] rep [repeat attribute_access]\n    construct before [repeat attribute_access]\n        rep [head count]\n    construct countWithSkip [number]\n        count [+ 2]\n    construct after [repeat attribute_access]\n        rep [tail countWithSkip]\n    by\n        funcName '( root before ') after\nend function\n\nrule containsAttributeAccess seeking [attribute_access]\n    match [attribute_access]\n        seeking\nend rule\n\n\n"}, 
	{ "txl/umpleJavaToPython.txl", "include \"Python.Grm\"\ninclude \"BooleanTranslation.txl\"\ninclude \"ImportProcessing.txl\"\ninclude \"ListTranslation.txl\"\ninclude \"MethodTranslation.txl\"\ninclude \"StatementTranslation.txl\"\ninclude \"ConstructorTranslation.txl\"\ninclude \"EnumTranslation.txl\"\ninclude \"ClassTranslation.txl\"\n\n%--------------------%\n%     Top level      %\n%--------------------%\n\nfunction main\n    replace [program] \n\t _[repeat package_statement] \n     _[repeat import_statement]\n     Classes [repeat class_declaration]\n    by\n\tClasses\n        [replaceConcreteClassesWithInheritance] \n        [replaceConcreteClassesNoInheritance]\n        [replaceInterfacesWithInheritance]\n        [replaceInterfacesNoInheritance] \nend function\n\n"}, 
	};

    boolean regenerateFiles = false;

    try {
        //Look for TXL folder
        Path tempDir = Paths.get("txl");

        if (Files.exists(tempDir)) {

            //Check last update time 
            Path tempVersion = Paths.get(versionPath);
            if (Files.exists(tempVersion)) {
                File versionFile = new File(versionPath);
                Scanner myReader = new Scanner(versionFile);
                
                if (myReader.hasNextLine()) {
                  String version = myReader.nextLine();

                    if (!version.equals(Integer.toString(TXL_VERSION))) {
                        regenerateFiles = true;
                    } 
                } else {
                	regenerateFiles = true;
                }

                myReader.close();
            } else {
				      regenerateFiles = true;
            }

            // If version number is valid, verify file integrity
            if (!regenerateFiles) {
            
                Path filePath;
                
            	for (int i = 0; i < filesData.length; i++) {
            	  filePath = Paths.get(filesData[i][0]);
            	  regenerateFiles = !Files.exists(filePath);
            	}
            }

        } else {
            regenerateFiles = true;
        }
    } catch (Exception e) {
        throw new UmpleCompilerException("An error occured while verifying the integrity of the Txl files.", e);
    }

    if (regenerateFiles) {

		File txlFolder = new File("txl");
	    txlFolder.mkdirs();
	       
	    //Write TXL Version File   
	    BufferedWriter bw = new BufferedWriter(new FileWriter(versionPath));
	    try {
	      bw.write(versionContent);
	      bw.flush();
	    } 
	    catch (Exception e) {
	      throw new UmpleCompilerException("An error occured while generating the TXL-Version.txt file.", e);
	    }
	    finally {
	      bw.close();
	    }	
	    
	    //Write all other TXL files	       
	    for (int i = 0; i < filesData.length; i++) {
		    bw = new BufferedWriter(new FileWriter(filesData[i][0]));
		    try {
		      bw.write(filesData[i][1]);
		      bw.flush();
		    }  
		    catch (Exception e) {
		      throw new UmpleCompilerException("An error occured while generating the " + filesData[i][0] + " file.", e);
		    }
		    finally {
		      bw.close();
		    }
	    }
	}
    
  }  
}
