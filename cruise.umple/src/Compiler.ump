/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

Command line tools: To compile Java, Php etc. generated by Umple

*/

namespace cruise.umple.compiler;

class CodeCompiler {

  depend java.util.*;
  depend java.util.regex.*;
  depend java.io.*;
  depend cruise.umple.compiler.*;
  depend cruise.umple.compiler.exceptions.*;
  depend cruise.umple.util.StringFormatter;
  depend javax.tools.ToolProvider;
  depend javax.tools.JavaCompiler;

  public static String console;
  public static boolean subsequentCompilation = false; // true if compile used more than once to quell messages

  public static boolean compile(UmpleModel model, String generator, boolean useExec, boolean beQuiet, String entryClass, String errorFileName, String... extraArgs) {
    boolean wasSuccessful = true;
    String extra = "";
    for(String arg:extraArgs)
    {
      extra+=arg;
    }
    for (UmpleElement currentElement : model.getUmpleElements())
    {
      if ("external".equals(currentElement.getModifier()))
      {
        continue;
      }
      if (entryClass.equals("-") || entryClass.equals(currentElement.getName())) {
        if(generator.equals("Java")) {
          wasSuccessful = wasSuccessful & compileJava(currentElement, model, useExec, beQuiet, errorFileName,  extra);
          subsequentCompilation = true;
        }
        else if (generator.equals("Php")) {
          wasSuccessful = wasSuccessful & compilePhp(currentElement, model, beQuiet, extra);
          subsequentCompilation = true;
        }
        else if (generator.equals("Python")) {
          wasSuccessful = wasSuccessful & compilePython(currentElement, model, beQuiet,errorFileName, extra);
          subsequentCompilation = true;
        }
        else {
          System.out.println("Compilation of generated code not supported yet for generator "+generator);
        }
      }
    }
    return wasSuccessful;
  }
 
  private static boolean compilePython(UmpleElement aClass, UmpleModel model, boolean beQuiet,String errorFileName, String args) {
    String path="";
    String base="";
    boolean isMain=false;
    for (GenerateTarget gt : model.getGenerates()) {
      if (gt.getLanguage().equals("Python")) {
        base = StringFormatter.addPathOrAbsolute( 
            model.getUmpleFile().getPath() +File.separator+ gt.getPath(), "");
        path = base + aClass.getPackageName().replace(".", File.separator);
      }
    }

    for(UmpleClass mainClass: CodeCompiler.getMainClasses(model)){
      if(aClass.getName().equals(mainClass.getName())){
        isMain=true;
      }
    }
    
    String filename = path + File.separator + aClass.getName() + ".py";
    String modelname = base + File.separator + model.getUmpleFile().getFileName();

    int retval=0;

    try {
      if(base.contains(" ") && !(beQuiet && subsequentCompilation)) {
        System.err.println("Warning: Compiling generated Python from a directory or path containing a space character may produce an error message from the Python compiler.");
      }
      
      BufferedReader reader;
      //used python3 for linux, use python for windows
      String pythonVersion="python3";

      if(System.getProperty("os.name").toLowerCase().contains("windows"))
        pythonVersion="python";

      String cmd=pythonVersion+" -m py_compile " +filename;
      String cmd2 = pythonVersion + " " + filename;

      //ProcessBuilder processBuilder = new ProcessBuilder(pythonVersion, "-m", "compileall", filename);
      //Process p = processBuilder.start();
      Process p = Runtime.getRuntime().exec(cmd);
      reader=new BufferedReader(new InputStreamReader(p.getErrorStream())); 

      // All output of the above should go to standard output
      try {
        retval=p.waitFor();
      }
      catch (InterruptedException e) {}

      String line;
      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        // no syntax error, check runtime error
        if(isMain){          
          //check runtime error
          Process p2 = Runtime.getRuntime().exec(cmd2);
          reader=new BufferedReader(new InputStreamReader(p2.getErrorStream()));

          try {
            retval=p2.waitFor();
          }
          catch (InterruptedException e) {}

          if(reader.ready()) {
            line = reader.readLine();
          }else{
            return (retval==0);
          }
        }else{
           return (retval==0);
        }    
      }

      StringBuilder builder = new StringBuilder();

      while (line!=null) {
        builder.append(line+"\n");
        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
      }

      //System.err.println("SHOULD SHOW IN TEST CONSOLE, model file path: "+modelname);
      String translatedOutput=translateLineToUmplePython(builder.toString(), modelname, filename);
      System.err.println(translatedOutput);

      if(retval!=0 && errorFileName != null) {
        String error = translatedOutput;
          try
          {
            File newFile = new File(errorFileName);
            newFile.createNewFile();   
          }
          catch (IOException ex)  
          {
            System.err.println(ex);
          }

          // Write to the file
          try (PrintWriter fileout = new PrintWriter(errorFileName)) 
          { 
//DEBUG to test if the the compiler writes to the file
            fileout.println(error);
          }  
          catch (FileNotFoundException ex) 
          {
            System.err.println(ex);
          }
      }
      
    } catch (IOException e) {
      println(e.getMessage());
      retval = 999;
    }

    return (retval == 0);
  }  

  private static boolean compilePhp(UmpleElement aClass, UmpleModel model, boolean beQuiet, String args) {
    String path="";
    String base="";
    for (GenerateTarget gt : model.getGenerates()) {
      if (gt.getLanguage().equals("Php")) {
        base = StringFormatter.addPathOrAbsolute( 
            model.getUmpleFile().getPath() +File.separator+ gt.getPath(), "");
        path = base;
      }
    }
    String filename = path + File.separator + aClass.getName() + ".php";
    int retval=0;

    try {
      if(base.contains(" ") && !(beQuiet && subsequentCompilation)) {
        System.err.println("Warning: Compiling generated Php from a directory or path containing a space character may produce an error message from the PhP compiler.");
      }
      
      BufferedReader reader;
      
      Process p = Runtime.getRuntime().exec("php -l -e " +filename);
      reader=new BufferedReader(new InputStreamReader(p.getInputStream())); 

      // All output of the above should go to standard output
      try {
        retval=p.waitFor(); 
      }
      catch (InterruptedException e) {}

      String line;
      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        line = null;
      }

      while (line!=null) {
        if(!line.startsWith("No syntax errors detected in")) {
          System.err.println(line);
          retval = 1;
        }

        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
      }
    } catch (IOException e) {
      println(e.getMessage());
      retval = 999;
    }
    return (retval == 0);
  }
  
  // Compiles graphviz files to various outputs: .svg (default), using dot
  public static boolean genDotDiagram (UmpleModel model,
    GenerateTarget gt, boolean beQuiet, String graphicFormat) {

    String generator = gt.getLanguage();
    
    String fileroot = model.getUmpleFile().getFileName();
    if (fileroot.endsWith(".ump")) {
      fileroot = fileroot.substring(0, fileroot.length() - 4);
    }
    if(generator.equals("GvClassDiagram")) {
      fileroot+="cd";
    }
    else if(generator.equals("GvEntityRelationshipDiagram")) {
      fileroot+="erd";
    }
    else if(generator.equals("GvFeatureDiagram")) {
      fileroot+="GvFeatureDiagram";
    }
    else if(generator.equals("GvClassTraitDiagram")) {
      fileroot+="cdt";
    }
    // Note that GV state diagrams do not have a fileroot suffix

    String path="";
    String extraPath=gt.getPath();

    if(extraPath.startsWith("/")) {
      // Absolute
      path=extraPath;
    }
    else
    {
      path=model.getUmpleFile().getPath() + File.separator + extraPath;
    }
    
    String inputFullPath=path + File.separator + fileroot + ".gv";
    String outputFullPath=path + File.separator + fileroot + "."+ graphicFormat;

    int retval=0;

    try {
      if(path.contains(" ") && !beQuiet) {
        System.err.println("Warning: Compiling generated Graphviz files from a directory or path containing a space character may produce an error message from the PhP compiler.");
      }
      
      BufferedReader reader;
      
      Process p = Runtime.getRuntime().exec("dot -T"+graphicFormat+" "+inputFullPath+" -o "+outputFullPath);
      reader=new BufferedReader(new InputStreamReader(p.getInputStream())); 

      // All output of the above should go to standard output
      try {
        retval=p.waitFor(); 
      }
      catch (InterruptedException e) {}

      String line;
      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        line = null;
      }

      while (line!=null) {
        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
      }
    } catch (IOException e) {
      println(e.getMessage());
      if(e.getMessage().startsWith("Cannot run program")) {
        println("It is necessary to install the graphviz package that includes the dot program in order to convert .gv files directly to graphical output files");
      }
      retval = 999;
    }
    return (retval == 0);
  }

  
  private static boolean compileJava(UmpleElement aClass, UmpleModel model, boolean useExec, boolean beQuiet, String errorFileName, String args) {
    String path="";
    String base="";
    for (GenerateTarget gt : model.getGenerates()) {
      if (gt.getLanguage().equals("Java")) {
        base = StringFormatter.addPathOrAbsolute( 
            model.getUmpleFile().getPath() +File.separator+ gt.getPath(), "");
        path = base + aClass.getPackageName().replace(".", File.separator);
      }
    }
    String filename = path + File.separator + aClass.getName() + ".java";
    boolean successful = true;
    PipedOutputStream out = null;

    try {
      if(base.contains(" ") && !(beQuiet && subsequentCompilation)) {
        System.err.println("Warning: Compiling generated Java from a directory or path containing a space character may produce an error message from the Java compiler.");
      }
      
      BufferedReader reader;
      
      // Method 1: Use tool provider
      if(!useExec) {
        // Determine a safe size of the output stream to capture any error messages
        // The larger the file the more error messages are likely
        // There were crashes when the buffer was not large enough for the number of messages
        File theFile = new File(filename);
        int bufferSizeToUse = Math.max(16384,((int)theFile.length() )*3);

        PipedInputStream in = new PipedInputStream(bufferSizeToUse);
        out = new PipedOutputStream(in);
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        compiler.run(null, null, out, "-cp",base,filename);

        reader=new BufferedReader(new InputStreamReader(in)); 
      }
      // Method 2: Use exec to compile files
      // This older approach seemed to use more CPU resources but may be more reliable
      else {
        Process p = Runtime.getRuntime().exec("javac -cp " + base + " " +filename+args);
        reader=new BufferedReader(new InputStreamReader(p.getErrorStream())); 
      }
      String line;

      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        line = null;
      }

      StringBuilder builder = new StringBuilder();

      while (line!=null) {
        System.err.println(translateLineToUmple(line, model));
        builder = builder.append(translateLineToUmple(line, model)+"\n");
        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
        successful = false;
      }

      // Write to the error file if given
      if(!successful && errorFileName != null) {
        String error = builder.toString().trim();
          try
          {
            File newFile = new File(errorFileName);
            newFile.createNewFile();   
          }
          catch (IOException ex)  
          {
            System.err.println(ex);
          }

          // Write to the file
          try (PrintWriter fileout = new PrintWriter(errorFileName)) 
          {
            fileout.println(error);
          }  
          catch (FileNotFoundException ex) 
          {
            System.err.println(ex);
          }
      }

    } catch (IOException e) {
      println(e.getMessage());
    }
    finally {
      if (out != null) {
        // close the PipedOutputStream cleanly
        try {
          out.close();
        }
        catch (IOException e) {} 
      }
    }
    
    return successful;
  }

  private static String translateLineToUmplePython(String error, String model, String filePath) {
      // retrieve filename and ignore pattern for main method error traceback msg
      String filenameParts[] = filePath.split("\\\\");
      String last = filenameParts[filenameParts.length - 1];
      String filename = last.substring(0, last.length() - 3);
      String ignorePattern = filename + ".main(";
      // System.err.println("ignore pattern: " + ignorePattern);

      // key functionName, value umpLine
      Map<String, Integer> hashMap = new HashMap<>();
      String functionName;
      int umpLine, pythonLine;

      String umpFile = model;
      String pythonFile = filePath;

      // store file lines in 2 String Arrays
      String[] umpFileCode = fileCodeArray(umpFile);
      String[] pythonFileCode = fileCodeArray(pythonFile);

      // locate funcions tagged with Python
      // pattern for functions tagged with Python
      String regex1 = "\\b\\w+\\s+(\\w+)\\s*\\([^{}]*?\\)\\s*Python\\s*";
      Pattern pattern1 = Pattern.compile(regex1);
      for (int i = 0; i < umpFileCode.length; i++) {
          Matcher matcher = pattern1.matcher(umpFileCode[i]);
          if (matcher.find()) {
              functionName = matcher.group(1);
                while(umpFileCode[i+1].trim().isEmpty()){
                    i++;
                }
                umpLine = i;
              hashMap.put(functionName, umpLine);
          }
      }

      if (!hashMap.containsKey("main")){
          // Regex pattern for simple Python main
          String regex2 = "\\s*Python\\s*\\{\\s*";
          Pattern pattern2 = Pattern.compile(regex2);
          for (int i = 0; i < umpFileCode.length; i++) {
              Matcher matcher2 = pattern2.matcher(umpFileCode[i]);

              if (matcher2.find()) {
                  functionName = "main";
                  while(umpFileCode[i+1].trim().isEmpty()){
                      i++;
                  }
                  umpLine = i;
                  hashMap.put("main", umpLine);
                  break;
              }
          }
      }

      // locate line number for python funciton in python format with python keyword
      String regex3 = "\\b(\\w+)\\s*\\(\\s*(.*?)\\s*\\)\\s*Python\\s*\\{?";
      Pattern pattern3 = Pattern.compile(regex3);

      for (int i = 0; i < umpFileCode.length; i++) {
          Matcher matcher3 = pattern3.matcher(umpFileCode[i]);
          if (matcher3.find() && !umpFileCode[i].contains("=") && !umpFileCode[i].contains(".")
                  && !umpFileCode[i].contains("new")) {
              functionName = matcher3.group(1);
              System.out.println("Found regular function: " + functionName + " at line: " + (i + 1));
              if (!hashMap.containsKey(functionName)) {
                  while(umpFileCode[i+1].trim().isEmpty()){
                    i++;
                  }
                  umpLine = i;
                  hashMap.put(functionName, umpLine);
              }
          }
      }


      // locate line number of regular function in java format without python keyword
      // Regex pattern for regular function
      String regex4 = "\\b\\w+\\s+(\\w+)\\s*\\([^{}]*?\\)\\s*";
      Pattern pattern4 = Pattern.compile(regex4);

      for (int i = 0; i < umpFileCode.length; i++) {
          Matcher matcher4 = pattern4.matcher(umpFileCode[i]);
          if (matcher4.find() && !umpFileCode[i].contains("=") && !umpFileCode[i].contains(".")
                  && !umpFileCode[i].contains("new")) {
              functionName = matcher4.group(1);
              if (!hashMap.containsKey(functionName)) {
                  while(umpFileCode[i+1].trim().isEmpty()){
                      i++;
                  }
                  umpLine = i;
                  hashMap.put(functionName, umpLine);
              }
          }
      }

      // locate line number of regular function in python format without python keyword
      String regex5 = "\\b(\\w+)\\s*\\(\\s*(.*?)\\s*\\)\\s*\\{?";
      Pattern pattern5 = Pattern.compile(regex5);

      for (int i = 0; i < umpFileCode.length; i++) {
          Matcher matcher5 = pattern5.matcher(umpFileCode[i]);
          if (matcher5.find() && !umpFileCode[i].contains("=") && !umpFileCode[i].contains(".")
                  && !umpFileCode[i].contains("new")) {
              functionName = matcher5.group(1);
              System.out.println("Found regular function: " + functionName + " at line: " + (i + 1));
              if (!hashMap.containsKey(functionName)) {
                  while (umpFileCode[i + 1].trim().isEmpty()) {
                      ++i;
                  }
                  umpLine = i;
                  hashMap.put(functionName, umpLine);
              }
          }
      }

      System.err.println("Functions:");
      for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
          System.err.println("Line: " + entry.getValue() + " function: " + entry.getKey());
      }

      StringBuilder builder = new StringBuilder();
      String[] errorLines = error.split("\n");
      String line;

      for (int i = 0; i < errorLines.length; i++) {
          line = errorLines[i];
          // if no error line number in the msg line
          if (!line.contains("line")) {
             builder.append(line + "\n");
          } else {
              // skip the error msg for main method traceback
              if (i < errorLines.length - 1 && errorLines[i + 1].contains(ignorePattern)) {
                  i++;
              } else {
                  // System.err.println("Line: "+line);
                  // convert the line for error msg
                  String[] words = line.split(" ");
                  for (int k = 0; k < words.length; k++) {
                      if (words[k].equals("line")) {
                          String num = words[k + 1];
                          boolean convert = false;
                          int lineNum = 0;
                          // discard end non-integar char
                          while (!convert) {
                              try {
                                  lineNum = Integer.parseInt(num);
                                  convert = true;
                              } catch (NumberFormatException e) {
                                  num = num.substring(0, num.length() - 1);
                              }
                          }

                          String pythonErrorFunction = getPythonLine(lineNum, pythonFileCode);
                          if(pythonErrorFunction == null){
                              // System.err.println("function not found for python file line: " + lineNum);
                              builder.append(line + "\n");
                              break;
                          }
                          // get function name and ump line number
                          String[] components = pythonErrorFunction.split("\\|\\|");
                          String errorFunctionName = components[0];
                          if (hashMap.containsKey(errorFunctionName)) {
                              // System.err.println("Function: " + errorFunctionName + "modelLine: " + hashMap.get(errorFunctionName) + " pythonLine: "
                              //        + components[1]);
                              int gap = hashMap.get(errorFunctionName) - Integer.parseInt(components[1]);
                              builder.append("model.ump:" + (lineNum + gap +1) + ": error in the ump code\n");
                              if(line.contains("indentation")){
                                  builder.append( line + "\n");
                              }
                                  
                             

                              break;
                          } else {
                              builder.append("function: " + errorFunctionName + "not found\n"+ line + "\n");
                              break;
                          }
                      }
                  }
              }
          }
      }
      return builder.toString();
  }

  private static String[] fileCodeArray(String fileName) {
      int count = 0;
      String[] fileCode = new String[0];

      try {
          BufferedReader reader = new BufferedReader(new FileReader(fileName));
          while (reader.readLine() != null) {
              count++;
          }

          reader.close();
          reader = new BufferedReader(new FileReader(fileName));
          fileCode = new String[count];

          for (int i = 0; i < count; i++) {
              fileCode[i] = reader.readLine();
          }

          reader.close();
      } catch (IOException e) {
          e.printStackTrace();
      }

      return fileCode;
  }

  private static String getPythonLine(int errorLine, String[] pythonFileCode) {
      int line = errorLine - 1;
      String regex = "def\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\([^\\)]*\\):";
      Pattern pattern = Pattern.compile(regex);
      Matcher matcher = null;
      while (line >= 0 && line < pythonFileCode.length) {
          matcher = pattern.matcher(pythonFileCode[line]);
          if (matcher.find())
              return matcher.group(1) + "||" + (1+line);

          line--;
      }
      return null;
  }

  // To do: Use model to determine generation path
  private static String translateLineToUmple(String line, UmpleModel model) {
    String modifiedLine = line;
    StackTraceElement ust;
    String javaFileName;
    int javaLineNumber;
    String lineParts[] = null;
    if(File.separator.equals("\\")) {
    	// Windows System
    	String tempLineParts[] = line.split(":", 4);
    	if(tempLineParts.length == 4) {
    		lineParts = new String[3];
    		lineParts[0] = tempLineParts[0] + ":" + tempLineParts[1];
    		lineParts[1] = tempLineParts[2];
    		lineParts[2] = tempLineParts[3];
    	} else {
    		lineParts = line.split(":",3);
    	}
    }
    
    else {
    	// Mac or Linux
    	lineParts = line.split(":",3);
    }
    
    // Case 1: No colons so nothing to translate
    if(lineParts.length < 3) {
      return line;
    }
    
    // case 2: no colon before .java, so nothing to translate
    if (!lineParts[0].endsWith(".java")) {
      return line;
    }
    
    // We have a line that needs translating
    String javaFileParts[] =
      lineParts[0].split("\\"+System.getProperty("file.separator"),-1);
    String javaFile = lineParts[0];//javaFileParts[javaFileParts.length-1];
    
    String declaringClass = javaFile.substring(0,javaFile.length()-5);
    for(int i=javaFileParts.length-2; i>=0 ; i--) {
      if(!javaFileParts[i].equals(".")) {
        declaringClass = javaFileParts[i]+"."+declaringClass;
      }
    }
    // System.err.println("**"+declaringClass+"**"+javaFile); //debug
    
    //Code Smell: javaToUmpleStackTrace needs to not be static
    ust = cruise.umple.util.ExceptionDumper.javaToUmpleStackTrace(
      new StackTraceElement(
        declaringClass,
        "",
        javaFile,
        Integer.parseInt(lineParts[1])),  "");
    
    // System.err.println("*"+lineParts[0]+"*"); // Debug
    
    if(ust==null) {
      return line;
    }
    return(ust.getFileName()+":"+ust.getLineNumber()+":"+lineParts[2]);
  }

  private static void println(String output)
  {
    console += output + System.lineSeparator();
    System.out.println(output);
  }

  public static String getSimpleFileName(String fileName)
  {

    int lastIndex = fileName.lastIndexOf("/");
    if (lastIndex == -1)
    {
      return fileName;
    }
    else
    {
      return fileName.substring(lastIndex+1, fileName.length());
    }
  }
  
  public static List<UmpleClass> getMainClasses(UmpleModel model)
  {
    List<UmpleClass> mainClasses = new ArrayList<UmpleClass>();
    for(UmpleClass uClass:model.getUmpleClasses())
    {
      if (!uClass.hasMethods()) {
            continue;
      }
      for (Method aMethod : uClass.getMethods()) 
      {
        
        if(!(aMethod.getExistsInLanguage("Java") || aMethod.getExistsInLanguage("Python"))) {
          continue;
        }
        String methodModifier = aMethod.getModifier().equals("") ? "public" : aMethod.getModifier();
        String methodName = aMethod.getName();
        String methodType = aMethod.getType();
        
	if(methodName.equals("main")&&methodType.equals("void")&&methodModifier.contains("public")&&methodModifier.contains("static"))
        {
          mainClasses.add(uClass);
	}

	} // end for loop for all methods in class

	} // end for loop for all classes in model



    return mainClasses;
  }

}
